Architecting a Resilient Real-Time Transcription Extension in Manifest V3: A Comprehensive Guide to State Management and Data Integrity


Introduction: Embracing the Stateless Paradigm of Manifest V3

The challenges encountered with a real-time transcription extension in Manifest V3—state loss between tabs, delayed timestamp display, and the disappearance of untimestamped text—are not isolated bugs. They are systemic consequences of a fundamental architectural shift imposed by the new extension platform. The transition from Manifest V2's persistent background pages to Manifest V3's ephemeral service workers necessitates a complete re-evaluation of how state is managed, data is persisted, and communication between extension components is orchestrated. Success in this new environment, particularly for high-frequency, real-time applications, requires a deliberate move away from the familiar model of a stateful, always-on application. Instead, developers must adopt a stateless, transactional model where persistent storage serves as the single, authoritative source of truth.
The issues identified are deeply interconnected and stem from a single root cause: treating the service worker as if it has a continuous, in-memory existence. This report will deconstruct this flawed assumption and provide a robust, production-ready architectural blueprint to resolve these issues. The analysis will proceed by mapping each problem to a core architectural solution:
State Loss: Addressed by implementing a resilient, per-tab state persistence strategy using chrome.storage.local as the canonical data store.
Timestamp Delay: Resolved by engineering a decoupled data pipeline that separates immediate data persistence from batched, performant UI updates, facilitated by a robust messaging channel.
Text Loss: Eliminated through the use of atomic "read-modify-write" operations against storage, ensuring no data is dropped, even when the service worker terminates unexpectedly.
This document serves as a comprehensive guide to re-architecting the extension for resilience, performance, and data integrity within the stringent constraints of the Manifest V3 framework.

Part I: The Manifest V3 Service Worker and Its Impact on State

A thorough understanding of the Manifest V3 service worker's lifecycle and operational constraints is the prerequisite for building any stable extension. The bugs observed in the transcription application are direct outcomes of this environment's design, which is fundamentally different from the persistent background scripts of Manifest V2.

1.1 The Ephemeral Lifecycle: A Paradigm Shift from Persistence

The most critical concept to internalize is that an extension's service worker is not a continuously running process. It is an event-driven script that is instantiated, executed in response to an event, and then terminated to conserve system resources. This model has profound implications for state management.
Idle Shutdown: Chrome's primary mechanism for resource conservation is the idle timer. A service worker will be terminated after approximately 30 seconds of inactivity. Inactivity is defined as a period with no incoming events (like messages or alarms) and no pending extension API calls. This behavior makes any data held in memory, such as in global variables, inherently volatile and certain to be lost during normal operation.
Execution Limits: Beyond the idle timer, there is a hard limit on the duration of any single event's processing. If an event handler takes more than five minutes to complete, the service worker will be forcibly terminated. While less of a concern for the small, frequent data chunks of a transcription service, this underscores the platform's intolerance for long-running, in-memory processes.
Event-Driven Revival: A terminated service worker is revived only when the browser dispatches an event for which it has a registered listener. Such events include chrome.runtime.onMessage, chrome.tabs.onActivated, or chrome.alarms.onAlarm. Upon revival, the service worker's script is re-executed from the top, establishing a completely new global scope. It does not resume from its previous state; it starts over entirely, with all variables reset to their initial values.
This lifecycle fundamentally changes the development paradigm. The service worker cannot be viewed as a persistent application but rather as a collection of stateless functions that are invoked on demand.

1.2 Why Global Variables and In-Memory Buffering Fail

The loss of untimestamped text is a classic symptom of attempting to buffer data in a service worker's global variable. Consider a typical but flawed approach:

JavaScript


// Flawed approach in service-worker.js
let interimTextBuffer = '';

function onNewTranscriptionData(data) {
  if (data.timestamp) {
    // Process and store the buffered text with the new timestamp
    persistData(interimTextBuffer + data.text, data.timestamp);
    interimTextBuffer = ''; // Clear buffer
  } else {
    // Buffer the text until a timestamp arrives
    interimTextBuffer += data.text;
  }
}


This pattern is guaranteed to fail in Manifest V3. If the service worker receives several text chunks without timestamps and then becomes idle for 30 seconds, it will be terminated. The contents of interimTextBuffer are wiped from memory. When the next event revives the worker, interimTextBuffer is re-initialized to an empty string, and the previously buffered text is lost forever.
This same principle of state reset explains why any global state, such as a variable tracking the currently active tab or the transcription status, will appear to be "lost." The service worker's memory is not a reliable place to store any information that needs to persist for longer than a single event's lifecycle. The only durable "memory" available to a Manifest V3 extension is a persistent storage mechanism, which must serve as the authoritative source of truth for all application state.

1.3 Communication Channels: The Pitfalls of sendMessage for Real-Time Streams

The choice of communication API between the service worker and content scripts is critical for real-time applications. While chrome.runtime.sendMessage is suitable for simple, one-off requests, it is architecturally unsound for high-frequency data streams due to a significant race condition.
When a content script calls sendMessage, if the service worker is inactive, the browser must first start it. This startup process is not instantaneous; it can take anywhere from 50 to over 100 milliseconds, as it involves creating the environment, executing the entire service worker script, and initializing its state. If the content script is sending a rapid stream of transcription data, messages sent during this startup window can be lost because the runtime.onMessage listener in the service worker has not yet been attached. This issue is particularly prevalent in scenarios where the sending context has a short lifetime, such as a beforeunload event, where the page may be destroyed before the service worker is fully awake to receive the message.
The architecturally correct solution for continuous, real-time data flow is chrome.runtime.connect. This API establishes a long-lived, persistent port between a content script and the service worker.
Stable Channel: Once established, the port provides a stable and ordered channel for messages. Messages sent via port.postMessage() are queued and delivered reliably, eliminating the startup latency race condition.
Worker Lifetime: An active connection port is one of the mechanisms that keeps a service worker alive, resetting its idle timer. While the port itself is subject to a five-minute lifetime before it must be reconnected, this is a manageable and predictable behavior, unlike the intermittent nature of sendMessage.
By using a long-lived port, the extension guarantees that the communication channel is always open and ready to receive data, which is essential for preventing the data loss and delays seen in the transcription UI.

Part II: A Robust State Management Strategy for Per-Tab Transcription

To eliminate state loss when switching tabs, the extension's architecture must be rebuilt around a centralized, persistent data store that is partitioned by tab. This section outlines the design of such a system using chrome.storage.local.

2.1 Choosing the Right Storage: chrome.storage.local

The chrome.storage API provides several options, but for this use case, chrome.storage.local is the only suitable choice.
localStorage: This is not a viable option. The standard Web Storage API (window.localStorage) is inaccessible from service workers, which is the central processing hub of a Manifest V3 extension.
chrome.storage.sync: This is designed for syncing small amounts of user settings across devices. Its quotas are highly restrictive—approximately 100 KB total and 8 KB per item—and it is subject to strict write-operation throttling. It is entirely inappropriate for storing potentially large and rapidly growing transcription logs.
chrome.storage.session: This storage area holds data in memory and is cleared when the browser session ends (i.e., when Chrome is closed). While faster than disk-based storage, it does not provide the necessary persistence for transcriptions that a user might expect to survive a browser restart.
chrome.storage.local: This is the ideal solution. It provides a generous storage quota (at least 10 MB), persists data across browser sessions until the extension is uninstalled, and is asynchronously accessible from all extension contexts, including the service worker and content scripts.1 It must be treated as the application's primary database.
The state of the application should not be considered "in memory" within the service worker or content script. Instead, those components should be viewed as clients that read from and write to the canonical state held in chrome.storage.local. Any action that modifies the state, such as starting a recording or receiving new text, must be structured as a transaction against this storage. The operation is only complete once the chrome.storage.local.set() promise resolves. This mindset shift is crucial for preventing a wide range of synchronization bugs that arise from treating ephemeral, in-memory variables as authoritative.

2.2 The Cornerstone: A Tab-Centric Storage Schema

The root of the state loss problem when switching tabs is the failure to associate data with its specific tab context. The solution is to structure the entire state object in chrome.storage.local around the unique and reliable identifier for each tab: its tab.id.1
A single top-level key (e.g., transcriptionState) should be used in storage. The value of this key will be an object whose own keys are the integer tab.ids. Each of these, in turn, will hold an object containing all state relevant to that specific tab. This schema effectively creates a separate, isolated namespace for each tab's data.
Table 2.1: Proposed chrome.storage.local Schema for Transcription State
Key
Type
Description
Example Value
transcriptionState
Object
Top-level container for all tab states.
{"101": {... }, "102": {... }}
transcriptionState[tabId]
Object
State object for a single tab, keyed by its ID.
{"isRecording": true, "transcriptChunks": [...]}
isRecording
Boolean
Flag to indicate if transcription is active for this tab.
true
transcriptChunks
Array
An ordered array of transcription segments.
``
chunk.text
String
A segment of transcribed text.
"Hello world."
chunk.timestamp
Number
Optional. The Unix timestamp for the start of the text segment.
1677610000000

This structure provides a clear and unambiguous data contract. When the service worker needs to update a transcript, it uses the tabId to locate the correct record. When a content script needs to display a transcript, it requests the data for its own tabId. This completely prevents data from one tab from overwriting or being confused with data from another.

2.3 Managing the State Lifecycle with chrome.tabs Events

To maintain the integrity of this storage schema, the extension must listen to chrome.tabs API events to manage the lifecycle of each tab's state.
Initialization (tabs.onCreated / tabs.onUpdated): When a user action initiates a transcription for a tab (e.g., clicking the extension action), the service worker should create the initial state object for that tabId within the transcriptionState map in storage. This ensures the data structure is in place before the first piece of transcription data arrives.
Cleanup (tabs.onRemoved): This is a critical step for performance and hygiene. An extension that fails to clean up its storage will eventually become bloated with orphaned data from closed tabs, potentially exceeding storage quotas. The service worker must implement a listener for chrome.tabs.onRemoved that deletes the entry for the closed tabId from the transcriptionState object.1
Context Switching (tabs.onActivated): This event fires when the user switches focus from one tab to another. It serves as the primary trigger for the UI to update its context. When a new tab is activated, the extension's UI (whether a popup or a side panel) should query the service worker for the state corresponding to the newly activated tab.id, ensuring the display is always synchronized with the active context.

Part III: Engineering a Lossless Real-Time Data Pipeline

With a robust state management foundation in place, the next step is to engineer the data flow from the transcription source to persistent storage and finally to the user interface. This pipeline must be designed to be both lossless and performant, directly addressing the issues of dropped text and delayed timestamps. The key is to architecturally decouple the act of persisting data from the act of synchronizing the UI.

3.1 The Service Worker as a Transaction Processor

The service worker's role in this architecture is not to hold state, but to process transactions against the state held in chrome.storage.local. When the external transcription engine produces a new chunk of data (text, and optionally a timestamp), it should be sent to the service worker. The service worker's sole responsibility upon receiving this data is to identify the target tabId and immediately execute an atomic update operation to persist that chunk to storage. This ensures that even if the service worker is terminated milliseconds later, the data is safe.

3.2 The Atomic "Read-Modify-Write" Cycle for Data Integrity

The chrome.storage.local.set operation overwrites any existing value for a given key. To append a new transcription chunk to the existing array of chunks for a tab, a "read-modify-write" pattern is essential. This involves fetching the current state, modifying it in memory, and then writing the entire updated state back to storage.
Encapsulating this logic in a single async function ensures atomicity at the application level. While chrome.storage itself doesn't have database-style transactions, using a single function prevents race conditions where multiple, uncoordinated read/write cycles might interfere with each other.
A robust implementation of this pattern would look as follows:

JavaScript


// In service-worker.js

async function appendToTranscript(tabId, newChunk) {
  try {
    // 1. READ the entire state object.
    const data = await chrome.storage.local.get('transcriptionState');
    const allStates = data.transcriptionState |

| {};

    // 2. MODIFY the specific tab's state in memory.
    // Get the current state for the tab, or initialize it if it's the first chunk.
    const currentTabState = allStates[tabId] |

| { isRecording: true, transcriptChunks: };
    
    // Append the new data chunk.
    currentTabState.transcriptChunks.push(newChunk);
    allStates[tabId] = currentTabState;

    // 3. WRITE the entire updated state object back.
    await chrome.storage.local.set({ transcriptionState: allStates });
  } catch (error) {
    console.error('Failed to append to transcript:', error);
  }
}


This pattern is the direct solution to the "loss of untimestamped text" problem. By treating every incoming piece of data—timestamped or not—as a chunk to be appended, and by executing this full cycle immediately upon receipt, the architecture guarantees that no data can be lost due to the service worker's ephemeral nature.

3.3 Decoupling Persistence from UI Updates: Buffering and Batching

While data persistence must be immediate for every chunk, UI synchronization must be managed for performance. Sending a message to the content script for every single word or short phrase would flood the communication channel, leading to high CPU usage and a sluggish, unresponsive UI. This is a likely cause of the "delayed timestamp display," where the rendering process cannot keep up with the high frequency of update messages.
The solution is to decouple these two processes. Persistence remains a high-frequency, per-chunk operation. UI updates, however, should be batched and sent at a controlled, lower frequency.
Immediate Persistence: The appendToTranscript function from section 3.2 is called for every incoming data chunk, ensuring data integrity above all else.
In-Memory Batching: A global variable in the service worker, such as let updateQueue = {}, can be used to temporarily buffer new chunks that need to be sent to the UI. After a chunk is persisted, it is also added to updateQueue[tabId].
Scheduled Flush with chrome.alarms: The chrome.alarms API is the correct tool for scheduling periodic tasks in a service worker. An alarm can be set to fire at a regular interval (e.g., every 500ms). The onAlarm listener will then iterate through the updateQueue, send one consolidated message containing all new chunks to each active tab's content script, and finally clear the queue.
This batching strategy is safe precisely because persistence is handled separately. If the service worker terminates before the alarm fires, the updateQueue is lost. However, the data itself is already safe in chrome.storage.local. As will be detailed in the next section, the content script is designed to re-synchronize from storage if it detects a communication gap, ensuring that the UI state eventually catches up to the canonical state, even if a few batched updates are missed due to a termination. This architecture prioritizes data integrity while optimizing for a smooth user experience.

Part IV: Synchronizing the User Interface with the Background State

The final piece of the architecture is to create a reliable communication link that pushes the persisted state to the content script for rendering. This involves establishing a stable channel and implementing a protocol for both initial state hydration and subsequent real-time updates. The content script should be designed as a passive view layer, or a "dumb terminal," whose only job is to render the state provided by the service worker.

4.1 Establishing a Persistent Channel: chrome.runtime.connect

As established in Part I, chrome.runtime.connect is the appropriate API for this task. The implementation requires coordination between the content script and the service worker.
Content Script Connection: Upon injection into a page, the content script's first action should be to establish a connection to the service worker. Naming the port is a best practice for clarity, especially if the extension might use ports for other purposes.
JavaScript
// In content.js
const port = chrome.runtime.connect({ name: 'transcription-ui' });


Service Worker Connection Handling: The service worker must have a listener for chrome.runtime.onConnect. When a new connection is made, the listener receives a port object. This object contains sender information, including the tab.id, which is crucial. The service worker should store these active ports in a global map, keyed by tab.id, to direct future updates to the correct UI.
JavaScript
// In service-worker.js
let activePorts = {};

chrome.runtime.onConnect.addListener((port) => {
  if (port.name === 'transcription-ui' && port.sender.tab) {
    const tabId = port.sender.tab.id;
    activePorts[tabId] = port;

    port.onDisconnect.addListener(() => {
      delete activePorts[tabId];
    });
  }
});


Lifecycle Management: Crucially, the service worker must also listen for the port's onDisconnect event. This event fires automatically when the content script's page is closed or reloaded. The handler for this event must remove the port from the activePorts map to prevent attempts to send messages to non-existent UIs and to manage memory.

4.2 Pushing Batched Updates to the UI

With the stable connection in place, the batching mechanism designed in Part III can now be implemented. The chrome.alarms handler, which fires periodically, will be responsible for pushing updates.
The alarm handler checks the updateQueue for pending UI updates.
For each tabId that has new chunks, it looks up the corresponding port in the activePorts map.
If a port exists, it sends a single message containing an array of all new chunks for that tab: port.postMessage({ type: 'transcript-update', payload: newChunks }).
The content script's port.onMessage listener receives this array and efficiently appends the new content to the DOM.
This process ensures that the UI updates in smooth, controlled bursts rather than a jarring, high-frequency stream, directly solving the performance issues that lead to delayed timestamp display.

4.3 Rehydrating State on Demand

A critical scenario to handle is when a UI is created or re-created after the transcription has already begun. This occurs when a user switches back to a tab they were previously transcribing, or if the extension is reloaded while a transcription is in progress. In these cases, the content script's UI is blank and needs to be "rehydrated" with the full, existing transcript.
The protocol for rehydration should be as follows:
Request State: Immediately after establishing a connection, the content script sends an initial message through the port to request the full state: port.postMessage({ type: 'get-full-state' }).
Retrieve and Send State: The service worker's message listener for the port (distinct from the global runtime.onMessage) receives this request. It then reads the complete state for that tabId from chrome.storage.local.
Deliver Full State: The service worker sends a message back through the same port containing the entire transcriptChunks array: port.postMessage({ type: 'full-state', payload: tabState.transcriptChunks }).
Render Full State: The content script's message listener has a handler for the 'full-state' message type. Upon receiving this payload, it clears any existing display and renders the entire transcript from scratch.
After this initial rehydration, the content script will seamlessly begin receiving the regular, incremental 'transcript-update' batches. This two-phase approach—initial full sync followed by batched updates—guarantees that the UI is always a correct and complete representation of the canonical state stored in chrome.storage.local, regardless of when the content script is loaded or reloaded.

Part V: Refactored Code and Implementation Guide

This section provides the complete, commented code that implements the robust architectural patterns discussed throughout this report. These files serve as a production-ready template for the real-time transcription extension.

5.1 manifest.json Configuration

The manifest file must declare the necessary permissions and correctly configure the service worker as an ES module, which enables cleaner code organization through imports.

JSON


{
  "manifest_version": 3,
  "name": "Real-Time Transcription MV3",
  "version": "1.0",
  "description": "A resilient real-time transcription extension using Manifest V3.",
  "permissions":,
  "host_permissions": [
    "<all_urls>"
  ],
  "background": {
    "service_worker": "service-worker.js",
    "type": "module"
  },
  "action": {
    "default_title": "Start Transcription"
  },
  "icons": {
    "128": "icon128.png"
  }
}



5.2 Revised Service Worker (service-worker.js)

The service worker acts as the central controller, managing state, processing data, and communicating with the UI.

JavaScript


// service-worker.js

// A map to hold long-lived connections to content script UIs, keyed by tabId.
const activePorts = {};
// A queue for batching UI updates, keyed by tabId.
let updateQueue = {};

const UI_UPDATE_ALARM_NAME = 'ui-update-alarm';

// --- State Management Functions ---

/**
 * Retrieves the entire transcription state object from storage.
 * @returns {Promise<object>} A promise that resolves to the transcriptionState object.
 */
async function getFullState() {
  const result = await chrome.storage.local.get('transcriptionState');
  return result.transcriptionState |

| {};
}

/**
 * Appends a new transcription chunk to the specified tab's state in storage.
 * This is the core atomic "read-modify-write" operation.
 * @param {number} tabId - The ID of the tab.
 * @param {object} newChunk - The chunk to append, e.g., { text, timestamp }.
 */
async function appendToTranscript(tabId, newChunk) {
  const allStates = await getFullState();
  const tabState = allStates[tabId] |

| { isRecording: true, transcriptChunks: };
  
  tabState.transcriptChunks.push(newChunk);
  allStates[tabId] = tabState;

  await chrome.storage.local.set({ transcriptionState: allStates });

  // Add the new chunk to the UI update queue.
  if (!updateQueue[tabId]) {
    updateQueue[tabId] =;
  }
  updateQueue[tabId].push(newChunk);
}

/**
 * Removes the state for a given tabId from storage.
 * @param {number} tabId - The ID of the tab to clean up.
 */
async function clearTabState(tabId) {
  const allStates = await getFullState();
  if (allStates[tabId]) {
    delete allStates[tabId];
    await chrome.storage.local.set({ transcriptionState: allStates });
  }
}

// --- Event Listeners ---

// Clean up storage when a tab is closed.
chrome.tabs.onRemoved.addListener((tabId) => {
  clearTabState(tabId);
  delete activePorts[tabId];
  delete updateQueue[tabId];
});

// Handle connections from content scripts.
chrome.runtime.onConnect.addListener((port) => {
  if (port.name === 'transcription-ui' && port.sender?.tab?.id) {
    const tabId = port.sender.tab.id;
    activePorts[tabId] = port;

    port.onMessage.addListener(async (msg) => {
      if (msg.type === 'get-full-state') {
        const allStates = await getFullState();
        const tabState = allStates[tabId];
        if (tabState) {
          port.postMessage({ type: 'full-state', payload: tabState.transcriptChunks });
        }
      }
    });

    port.onDisconnect.addListener(() => {
      delete activePorts[tabId];
    });
  }
});

// Alarm listener for batching UI updates.
chrome.alarms.onAlarm.addListener((alarm) => {
  if (alarm.name === UI_UPDATE_ALARM_NAME) {
    for (const tabId in updateQueue) {
      if (activePorts[tabId] && updateQueue[tabId].length > 0) {
        activePorts[tabId].postMessage({
          type: 'transcript-update',
          payload: updateQueue[tabId],
        });
      }
    }
    // Clear the queue after sending updates.
    updateQueue = {};
  }
});

// --- Initialization and Mock Data ---

// Create the alarm when the extension is installed.
chrome.runtime.onInstalled.addListener(() => {
  chrome.alarms.create(UI_UPDATE_ALARM_NAME, {
    periodInMinutes: 1 / 120, // Fire every 500ms
  });
});

// Example: Simulate receiving transcription data for the active tab.
// In a real extension, this would come from your transcription engine.
async function simulateTranscription(tabId) {
    const texts = ["Hello world, ", "this is a test ", "of the real-time ", "transcription system. "];
    for (let i = 0; i < 100; i++) {
        const text = texts[Math.floor(Math.random() * texts.length)];
        const hasTimestamp = Math.random() > 0.7;
        const chunk = {
            text: text,
            timestamp: hasTimestamp? Date.now() : null
        };
        await appendToTranscript(tabId, chunk);
        await new Promise(resolve => setTimeout(resolve, 200)); // Simulate delay
    }
}

// Example: Start transcription when the action icon is clicked.
chrome.action.onClicked.addListener((tab) => {
    console.log(`Starting transcription for tab ${tab.id}`);
    simulateTranscription(tab.id);
    chrome.scripting.executeScript({
        target: { tabId: tab.id },
        files: ['content.js']
    });
});



5.3 Updated Content Script (content.js)

The content script is now a "dumb terminal" responsible only for rendering data provided by the service worker.

JavaScript


// content.js

let transcriptContainer;

function initializeUI() {
  // Avoid re-injecting the UI if it already exists.
  if (document.getElementById('transcript-container')) {
    return;
  }

  transcriptContainer = document.createElement('div');
  transcriptContainer.id = 'transcript-container';
  transcriptContainer.style.position = 'fixed';
  transcriptContainer.style.bottom = '10px';
  transcriptContainer.style.right = '10px';
  transcriptContainer.style.width = '300px';
  transcriptContainer.style.height = '400px';
  transcriptContainer.style.backgroundColor = 'white';
  transcriptContainer.style.border = '1px solid black';
  transcriptContainer.style.overflowY = 'auto';
  transcriptContainer.style.zIndex = '9999';
  transcriptContainer.style.padding = '10px';
  transcriptContainer.style.fontFamily = 'sans-serif';

  document.body.appendChild(transcriptContainer);
}

function renderChunks(chunks) {
  if (!transcriptContainer) return;
  
  chunks.forEach(chunk => {
    const p = document.createElement('p');
    p.style.margin = '0 0 5px 0';
    let content = chunk.text;
    if (chunk.timestamp) {
      const time = new Date(chunk.timestamp).toLocaleTimeString();
      content = `[${time}] ${content}`;
      p.style.fontWeight = 'bold';
    }
    p.textContent = content;
    transcriptContainer.appendChild(p);
  });

  // Auto-scroll to the bottom.
  transcriptContainer.scrollTop = transcriptContainer.scrollHeight;
}

function fullRender(chunks) {
  if (!transcriptContainer) return;
  transcriptContainer.innerHTML = ''; // Clear previous content
  renderChunks(chunks);
}

// --- Main Logic ---

initializeUI();

// Establish a long-lived connection.
const port = chrome.runtime.connect({ name: 'transcription-ui' });

// Listen for messages from the service worker.
port.onMessage.addListener((msg) => {
  if (msg.type === 'full-state') {
    console.log('Received full state:', msg.payload);
    fullRender(msg.payload);
  } else if (msg.type === 'transcript-update') {
    console.log('Received incremental update:', msg.payload);
    renderChunks(msg.payload);
  }
});

// Request the full state upon connection to rehydrate the UI.
port.postMessage({ type: 'get-full-state' });
